"""
This module provides functionality to visualize a pipeline of tasks using graphviz.

Functions:
    visualize(pipeline, to_file=None): Display a pipeline of tasks 
                                       or save its visualization to a file.
"""

__all__ = ["visualize"]


import os
import tempfile
import graphviz
from matplotlib import pyplot as plt

from dagpipe.task_core import Task, TaskReference
from dagpipe.pipeline import Pipeline


def visualize(pipeline: Pipeline, to_file: str | None = None):
    """
    Visualize a pipeline of tasks using graphviz or save it to a file.
    Displayed image is generated by matplotlib.

    Args:
        pipeline (Pipeline): The pipeline to be visualized.
        to_file (str, optional): The file path to save the visualization. 
                                 If None, the visualization is displayed.
    """
    graph = _build_graph(pipeline)
    if to_file:
        graph.render(to_file, format='png', view=False)
    else:
        with tempfile.TemporaryDirectory() as tempdir:
            file_path = os.path.join(tempdir, 'graph')
            graph.render(file_path, format='png', view=False)
            img = plt.imread(file_path + ".png")
            plt.imshow(img)
            plt.axis("off")

def _build_graph(pipeline : Pipeline):
    """
    Execute the pipeline of tasks with optional initial arguments.

    Args:
        *args: Positional arguments to be passed to the initial task.
        **kwargs: Keyword arguments to be passed to the initial task.

    Returns:
        list: The evaluated results of the output tasks.
    """
    dot = graphviz.Digraph(strict=False, format='png')
    for task in pipeline.tasks:
        if isinstance(task, TaskReference):
            task = task.task
        label = task.name
        color="black"
        if pipeline.conditional_stops:
            if task.name in pipeline.conditional_stops:
                stop = pipeline.conditional_stops[task.name]
                label, color = __update_node_attrs_for_stop(stop, label)
        dot.node(__get_node_name(task), label=label, color=color)

    created_edges = set()
    for task in pipeline.tasks:
        if isinstance(task, Task):
            if isinstance(task, TaskReference):
                task = task.task
            for arg in task.args + tuple(task.kwargs.values()):
                if not isinstance(arg, Task):
                    continue
                edge, edge_kwargs = __define_edge(task, arg)
                label = edge_kwargs.get("label", None)
                if (edge, label) not in created_edges:
                    dot.edge(*edge,  **edge_kwargs)
                    created_edges.add((edge, label))
    return dot


def __define_edge(task_to: Task, task_from: Task):
    if isinstance(task_from, TaskReference):
        edge = __get_node_name(task_from.task), __get_node_name(task_to)
        edge_kwargs = dict(label=task_from.name)
    else: # Normal Task
        edge = __get_node_name(task_from), __get_node_name(task_to)
        edge_kwargs= dict(color='black')
    return edge,edge_kwargs


def __get_node_name(task):
    node_name = f"{task.name}_{str(id(task))}"
    for symbol in "[] <>,:":
        node_name = node_name.replace(symbol, "")
    return node_name


def __update_node_attrs_for_stop(stop, label):
    if hasattr(stop, "name"):
        stop_name = stop.name
    elif hasattr(stop, "__name__"):
        stop_name = stop.__name__
    else:
        stop_name = repr(stop)
    color="red"
    label = f"{label}\nstops if\n{stop_name}"
    return label,color

